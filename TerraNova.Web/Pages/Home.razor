@page "/"
@using TerraNova.GameLogic
@using TerraNova.Shared
@inject ThreeJsRenderer Renderer
@inject IJSRuntime JS

<PageTitle>Terra Nova - Web Client</PageTitle>

<div style="position: fixed; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; font-family: monospace; z-index: 1000;">
    <h3 style="margin: 0 0 5px 0;">Terra Nova Web Client</h3>
    <p style="margin: 0;">Chunk Streaming Mode</p>
    <p style="margin: 5px 0 0 0; font-size: 12px;">@statusMessage</p>
</div>

<!-- Crosshair (uses UIConstants.Crosshair.Length=19px, Thickness=2px from TerraNova.Shared) -->
<div style="position: fixed; top: 50%; left: 50%; z-index: 999; pointer-events: none; width: 0; height: 0;">
    <div style="position: absolute; width: @((int)UIConstants.Crosshair.Length)px; height: @((int)UIConstants.Crosshair.Thickness)px; background: rgba(255,255,255,0.8); top: 0; left: 0; transform: translate(-50%, -50%);"></div>
    <div style="position: absolute; width: @((int)UIConstants.Crosshair.Thickness)px; height: @((int)UIConstants.Crosshair.Length)px; background: rgba(255,255,255,0.8); top: 0; left: 0; transform: translate(-50%, -50%);"></div>
</div>

@code {
    private string statusMessage = "Initializing...";
    private World? world = null;
    private GameEngine? gameEngine = null;
    private System.Threading.Timer? positionUpdateTimer = null;
    private int chunksReceived = 0;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Give Three.js a moment to initialize
            await Task.Delay(500);

            // Initialize noise texture using shared C# code
            await Renderer.InitializeNoiseTextureAsync();

            // Initialize block colors from shared C# code (single source of truth)
            await Renderer.InitializeBlockColorsAsync();

            statusMessage = "Connecting to server...";
            StateHasChanged();

            // Connect to the server via WebSocket
            await ConnectToServer();
        }
    }

    private async Task ConnectToServer()
    {
        try
        {
            // Create a reference to this component for JavaScript to call back into
            var dotNetRef = DotNetObjectReference.Create(this);

            // Store the reference in JavaScript using the helper function
            await JS.InvokeVoidAsync("terraNova.setHomeComponentReference", dotNetRef);

            // Connect to the server with chunk streaming support
            await JS.InvokeVoidAsync("eval", @"
                const serverHost = window.location.hostname;
                terraNovaNetwork.connect(
                    `ws://${serverHost}:5000/ws`,
                    (blocks) => {
                        // Legacy full world data handler (no longer used with chunk streaming)
                        console.log('Received legacy world data (ignored in chunk streaming mode)');
                    },
                    async (x, y, z, blockType) => {
                        // Block update handler
                        console.log('Block update:', x, y, z, blockType);
                        if (window.terraNovaHomeComponent) {
                            await window.terraNovaHomeComponent.invokeMethodAsync('HandleBlockUpdate', x, y, z, blockType);
                        }
                    },
                    async (chunkX, chunkZ, blocks) => {
                        // Chunk data handler
                        console.log('Chunk data received:', chunkX, chunkZ, blocks.length, 'blocks');
                        if (window.terraNovaHomeComponent) {
                            await window.terraNovaHomeComponent.invokeMethodAsync('HandleChunkData', chunkX, chunkZ, JSON.stringify(blocks));
                        }
                    }
                );
            ");

            // Wait for connection
            await Task.Delay(1000);

            statusMessage = "Connected! Initializing world...";
            StateHasChanged();

            // Initialize empty world and GameEngine immediately
            await InitializeWorldWithChunkStreaming();
        }
        catch (Exception ex)
        {
            statusMessage = $"Connection failed: {ex.Message}";
            StateHasChanged();
        }
    }

    private async Task InitializeWorldWithChunkStreaming()
    {
        try
        {
            await JS.InvokeVoidAsync("console.log", "Initializing empty world with chunk streaming...");

            // Create empty world
            world = new World();
            gameEngine = new GameEngine(Renderer);

            // Hook up chunk request callback BEFORE calling SetWorld
            gameEngine.OnChunkRequestNeeded = async (chunks) =>
            {
                await JS.InvokeVoidAsync("console.log", $"GameEngine requesting {chunks.Length} chunks from server");

                // Convert Vector2i[] to JS-friendly format
                var chunkPositions = chunks.Select(c => new { x = c.X, z = c.Z }).ToArray();
                var jsArray = System.Text.Json.JsonSerializer.Serialize(chunkPositions);

                // Request chunks from server
                await JS.InvokeVoidAsync("eval", $"terraNovaNetwork.requestChunks({jsArray})");
            };

            // Now set the world (this creates ChunkLoader with the callback)
            gameEngine.SetWorld(world);

            await JS.InvokeVoidAsync("console.log", "GameEngine initialized with empty world and chunk streaming");

            statusMessage = $"World initialized! Chunks loading... ({chunksReceived} received)";
            StateHasChanged();

            // Start player position update timer (update every 100ms)
            positionUpdateTimer = new System.Threading.Timer(async _ =>
            {
                try
                {
                    await UpdatePlayerPosition();
                }
                catch (Exception ex)
                {
                    await JS.InvokeVoidAsync("console.error", $"Error updating player position: {ex.Message}");
                }
            }, null, TimeSpan.FromMilliseconds(100), TimeSpan.FromMilliseconds(100));
        }
        catch (Exception ex)
        {
            statusMessage = $"Error initializing world: {ex.Message}";
            StateHasChanged();
        }
    }

    private async Task UpdatePlayerPosition()
    {
        if (gameEngine == null) return;

        try
        {
            // Get camera position from Three.js renderer
            var posJson = await JS.InvokeAsync<string>("eval", "JSON.stringify(window.terraNovaRenderer.getCameraPosition())");
            var pos = System.Text.Json.JsonSerializer.Deserialize<CameraPosition>(posJson);

            if (pos != null)
            {
                var playerPos = new Vector3(pos.X, pos.Y, pos.Z);
                gameEngine.UpdatePlayerPosition(playerPos);
            }
        }
        catch
        {
            // Silently ignore errors (camera might not be ready yet)
        }
    }

    /// <summary>
    /// Handle chunk data from the server
    /// </summary>
    [Microsoft.JSInterop.JSInvokable]
    public async Task HandleChunkData(int chunkX, int chunkZ, string blocksJson)
    {
        try
        {
            await JS.InvokeVoidAsync("console.log", $"HandleChunkData called: chunk ({chunkX},{chunkZ})");

            if (world == null || gameEngine == null)
            {
                await JS.InvokeVoidAsync("console.warn", "World or GameEngine not initialized yet");
                return;
            }

            // Deserialize blocks
            var blocks = System.Text.Json.JsonSerializer.Deserialize<List<BlockData>>(blocksJson);
            if (blocks == null) return;

            await JS.InvokeVoidAsync("console.log", $"Received {blocks.Count} blocks for chunk ({chunkX},{chunkZ})");

            // Add blocks to world
            foreach (var block in blocks)
            {
                world.SetBlock(block.X, block.Y, block.Z, (BlockType)block.Type);

                // Also update block interaction system
                await JS.InvokeVoidAsync("eval", $"if (window.terraNovaBlockInteraction) {{ window.terraNovaBlockInteraction.setBlockData({block.X}, {block.Y}, {block.Z}, {block.Type}); }}");
            }

            // Notify GameEngine that chunk was received
            gameEngine.NotifyChunkReceived(new Vector2i(chunkX, chunkZ));

            // Update GameEngine to regenerate meshes
            await Task.Yield(); // Let UI update first
            gameEngine.Update(0); // Delta time doesn't matter for mesh regeneration

            chunksReceived++;
            statusMessage = $"Chunks loaded: {chunksReceived}";
            StateHasChanged();

            await JS.InvokeVoidAsync("console.log", $"Chunk ({chunkX},{chunkZ}) processed by GameEngine");
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"Error in HandleChunkData: {ex.Message}");
        }
    }

    /// <summary>
    /// Handle block updates from the server
    /// </summary>
    [Microsoft.JSInterop.JSInvokable]
    public async Task HandleBlockUpdate(int x, int y, int z, int blockType)
    {
        try
        {
            await JS.InvokeVoidAsync("console.log", $"HandleBlockUpdate called: ({x}, {y}, {z}) = {blockType}");

            if (world == null || gameEngine == null)
            {
                await JS.InvokeVoidAsync("console.warn", "World or GameEngine not initialized yet");
                return;
            }

            // Update world data via GameEngine
            gameEngine.NotifyBlockUpdate(x, y, z, (BlockType)blockType);

            // Defer mesh regeneration
            await Task.Yield();
            gameEngine.Update(0);

            await JS.InvokeVoidAsync("console.log", $"Block update at ({x}, {y}, {z}) processed by GameEngine");
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"Error in HandleBlockUpdate: {ex.Message}");
        }
    }

    /// <summary>
    /// Helper class for JSON deserialization of block data
    /// </summary>
    private class BlockData
    {
        [System.Text.Json.Serialization.JsonPropertyName("x")]
        public int X { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("y")]
        public int Y { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("z")]
        public int Z { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public byte Type { get; set; }
    }

    /// <summary>
    /// Helper class for camera position from Three.js
    /// </summary>
    private class CameraPosition
    {
        [System.Text.Json.Serialization.JsonPropertyName("x")]
        public float X { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("y")]
        public float Y { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("z")]
        public float Z { get; set; }
    }

    public void Dispose()
    {
        positionUpdateTimer?.Dispose();
    }
}
