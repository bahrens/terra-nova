@page "/"
@using TerraNova.GameLogic
@using TerraNova.Shared
@inject ThreeJsRenderer Renderer
@inject IJSRuntime JS

<PageTitle>Terra Nova - Web Client</PageTitle>

<div style="position: fixed; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; font-family: monospace; z-index: 1000;">
    <h3 style="margin: 0 0 5px 0;">Terra Nova Web Client</h3>
    <p style="margin: 0;">Network Mode</p>
    <p style="margin: 5px 0 0 0; font-size: 12px;">@statusMessage</p>
</div>

<!-- Crosshair (uses UIConstants.Crosshair.Length=19px, Thickness=2px from TerraNova.Shared) -->
<div style="position: fixed; top: 50%; left: 50%; z-index: 999; pointer-events: none; width: 0; height: 0;">
    <div style="position: absolute; width: @((int)UIConstants.Crosshair.Length)px; height: @((int)UIConstants.Crosshair.Thickness)px; background: rgba(255,255,255,0.8); top: 0; left: 0; transform: translate(-50%, -50%);"></div>
    <div style="position: absolute; width: @((int)UIConstants.Crosshair.Thickness)px; height: @((int)UIConstants.Crosshair.Length)px; background: rgba(255,255,255,0.8); top: 0; left: 0; transform: translate(-50%, -50%);"></div>
</div>

@code {
    private string statusMessage = "Initializing...";
    private World? world = null; // Store world reference for block updates
    private GameEngine? gameEngine = null; // GameEngine manages world state and rendering

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Give Three.js a moment to initialize
            await Task.Delay(500);

            // Initialize noise texture using shared C# code
            await Renderer.InitializeNoiseTextureAsync();

            // Initialize block colors from shared C# code (single source of truth)
            await Renderer.InitializeBlockColorsAsync();

            statusMessage = "Connecting to server...";
            StateHasChanged();

            // Connect to the server via WebSocket
            await ConnectToServer();
        }
    }

    private async Task ConnectToServer()
    {
        try
        {
            // Create a reference to this component for JavaScript to call back into
            var dotNetRef = DotNetObjectReference.Create(this);

            // Store the reference in JavaScript using the helper function
            await JS.InvokeVoidAsync("terraNova.setHomeComponentReference", dotNetRef);

            // Connect to the server (running on port 5000 by default)
            // Use window.location.hostname to connect to the same host that served this page
            await JS.InvokeVoidAsync("eval", @"
                const serverHost = window.location.hostname;
                terraNovaNetwork.connect(
                    `ws://${serverHost}:5000/ws`,
                    (blocks) => {
                        console.log('Received world data from server:', blocks.length, 'blocks');

                        // Group blocks by chunk
                        const chunks = {};
                        blocks.forEach(block => {
                            const chunkX = Math.floor(block.x / 16);
                            const chunkY = Math.floor(block.y / 16);
                            const chunkZ = Math.floor(block.z / 16);
                            const chunkKey = `${chunkX},${chunkY},${chunkZ}`;

                            if (!chunks[chunkKey]) {
                                chunks[chunkKey] = {
                                    chunkX: chunkX,
                                    chunkY: chunkY,
                                    chunkZ: chunkZ,
                                    blocks: []
                                };
                            }
                            chunks[chunkKey].blocks.push(block);
                        });

                        // Process each chunk via C# (we'll call back via JSInterop)
                        window.terraNovaReceivedChunks = chunks;
                    },
                    async (x, y, z, blockType) => {
                        console.log('Block update:', x, y, z, blockType);
                        if (window.terraNovaHomeComponent) {
                            await window.terraNovaHomeComponent.invokeMethodAsync('HandleBlockUpdate', x, y, z, blockType);
                        } else {
                            console.error('terraNovaHomeComponent not available for block update callback');
                        }
                    }
                );
            ");

            // Wait a bit for connection
            await Task.Delay(1000);

            statusMessage = "Connected! Loading world...";
            StateHasChanged();

            // Poll for received chunks and process them
            await ProcessServerChunks();
        }
        catch (Exception ex)
        {
            statusMessage = $"Connection failed: {ex.Message}";
            StateHasChanged();
        }
    }

    private async Task ProcessServerChunks()
    {
        try
        {
            await JS.InvokeVoidAsync("console.log", "ProcessServerChunks starting...");

            // Get the chunks received from JavaScript
            var chunksJson = await JS.InvokeAsync<string>("eval", "JSON.stringify(window.terraNovaReceivedChunks || {})");
            await JS.InvokeVoidAsync("console.log", $"Chunks JSON length: {chunksJson?.Length ?? 0}");

            if (string.IsNullOrEmpty(chunksJson) || chunksJson == "{}")
            {
                statusMessage = "Waiting for world data...";
                StateHasChanged();
                await JS.InvokeVoidAsync("console.log", "No chunks yet, retrying...");
                // Retry after a delay
                await Task.Delay(500);
                await ProcessServerChunks();
                return;
            }

            await JS.InvokeVoidAsync("console.log", "Deserializing chunks...");
            // Parse and process chunks via C#
            var chunks = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, ChunkData>>(chunksJson);
            await JS.InvokeVoidAsync("console.log", $"Deserialized {chunks?.Count ?? 0} chunks");

            if (chunks != null && chunks.Count > 0)
            {
                await JS.InvokeVoidAsync("console.log", "Creating world and GameEngine...");
                world = new World();
                gameEngine = new GameEngine(Renderer);

                // Add all blocks to the world
                await JS.InvokeVoidAsync("console.log", "Adding blocks to world...");
                foreach (var chunkData in chunks.Values)
                {
                    foreach (var block in chunkData.Blocks)
                    {
                        world.SetBlock(block.X, block.Y, block.Z, (BlockType)block.Type);

                        // Also populate block interaction system's world data
                        await JS.InvokeVoidAsync("eval", $"if (window.terraNovaBlockInteraction) {{ window.terraNovaBlockInteraction.setBlockData({block.X}, {block.Y}, {block.Z}, {block.Type}); }}");
                    }
                }

                // Initialize GameEngine with the populated world
                await JS.InvokeVoidAsync("console.log", "Initializing GameEngine with world...");
                gameEngine.SetWorld(world);

                // GameEngine.Update will regenerate all chunk meshes
                await JS.InvokeVoidAsync("console.log", "Updating GameEngine to generate meshes...");
                gameEngine.Update(0); // Delta time doesn't matter for initial mesh generation

                await JS.InvokeVoidAsync("console.log", "All chunks rendered by GameEngine!");
                statusMessage = $"World loaded! ({chunks.Count} chunks)";
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"Error loading world: {ex.Message}";
            StateHasChanged();
        }
    }

    /// <summary>
    /// Handle block updates from the server and let GameEngine rebuild affected chunks
    /// </summary>
    [Microsoft.JSInterop.JSInvokable]
    public async Task HandleBlockUpdate(int x, int y, int z, int blockType)
    {
        try
        {
            await JS.InvokeVoidAsync("console.log", $"HandleBlockUpdate called: ({x}, {y}, {z}) = {blockType}");

            if (world == null || gameEngine == null)
            {
                await JS.InvokeVoidAsync("console.warn", "World or GameEngine not initialized yet, skipping block update");
                return;
            }

            // Update world data via GameEngine
            gameEngine.NotifyBlockUpdate(x, y, z, (BlockType)blockType);

            // Defer mesh regeneration to avoid blocking UI
            await Task.Yield(); // Let UI update first
            gameEngine.Update(0); // Delta time doesn't matter for mesh regeneration

            await JS.InvokeVoidAsync("console.log", $"Block update at ({x}, {y}, {z}) processed by GameEngine");
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"Error in HandleBlockUpdate: {ex.Message}");
        }
    }

    /// <summary>
    /// Helper class for JSON deserialization of chunk data received from JavaScript.
    /// This mirrors the chunk structure created in the JavaScript network client
    /// when grouping blocks by chunk position.
    /// </summary>
    private class ChunkData
    {
        [System.Text.Json.Serialization.JsonPropertyName("chunkX")]
        public int ChunkX { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("chunkY")]
        public int ChunkY { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("chunkZ")]
        public int ChunkZ { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("blocks")]
        public List<BlockData> Blocks { get; set; } = new();
    }

    /// <summary>
    /// Helper class for JSON deserialization of block data received from JavaScript.
    /// This mirrors the BlockData structure from TerraNova.Shared/NetworkMessages.cs
    /// but uses JSON property names for deserialization from the web client.
    /// </summary>
    private class BlockData
    {
        [System.Text.Json.Serialization.JsonPropertyName("x")]
        public int X { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("y")]
        public int Y { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("z")]
        public int Z { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public byte Type { get; set; }
    }
}
